// Generated by gen.go, DON NOT EDIT!
package query

import (
	"github.com/gopherd/doge/erron"
)

type Parser struct {
	errors erron.Errors
	q      Query
}

func NewParser(q Query) *Parser {
	return &Parser{
		q: q,
	}
}

func (p *Parser) next() bool {
	return p.errors.Len() == 0
}

func (p *Parser) Err() error {
	return p.errors.All()
}

func (p *Parser) Int(val *int, key string) *Parser {
	if p.next() {
		v, err := RequiredInt(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) IntOr(val *int, key string, dft int) *Parser {
	if p.next() {
		v, err := Int(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int8(val *int8, key string) *Parser {
	if p.next() {
		v, err := RequiredInt8(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int8Or(val *int8, key string, dft int8) *Parser {
	if p.next() {
		v, err := Int8(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int16(val *int16, key string) *Parser {
	if p.next() {
		v, err := RequiredInt16(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int16Or(val *int16, key string, dft int16) *Parser {
	if p.next() {
		v, err := Int16(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int32(val *int32, key string) *Parser {
	if p.next() {
		v, err := RequiredInt32(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int32Or(val *int32, key string, dft int32) *Parser {
	if p.next() {
		v, err := Int32(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int64(val *int64, key string) *Parser {
	if p.next() {
		v, err := RequiredInt64(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Int64Or(val *int64, key string, dft int64) *Parser {
	if p.next() {
		v, err := Int64(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint(val *uint, key string) *Parser {
	if p.next() {
		v, err := RequiredUint(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) UintOr(val *uint, key string, dft uint) *Parser {
	if p.next() {
		v, err := Uint(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint8(val *uint8, key string) *Parser {
	if p.next() {
		v, err := RequiredUint8(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint8Or(val *uint8, key string, dft uint8) *Parser {
	if p.next() {
		v, err := Uint8(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint16(val *uint16, key string) *Parser {
	if p.next() {
		v, err := RequiredUint16(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint16Or(val *uint16, key string, dft uint16) *Parser {
	if p.next() {
		v, err := Uint16(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint32(val *uint32, key string) *Parser {
	if p.next() {
		v, err := RequiredUint32(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint32Or(val *uint32, key string, dft uint32) *Parser {
	if p.next() {
		v, err := Uint32(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint64(val *uint64, key string) *Parser {
	if p.next() {
		v, err := RequiredUint64(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Uint64Or(val *uint64, key string, dft uint64) *Parser {
	if p.next() {
		v, err := Uint64(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Bool(val *bool, key string) *Parser {
	if p.next() {
		v, err := RequiredBool(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) BoolOr(val *bool, key string, dft bool) *Parser {
	if p.next() {
		v, err := Bool(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) String(val *string, key string) *Parser {
	if p.next() {
		v, err := RequiredString(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) StringOr(val *string, key string, dft string) *Parser {
	if p.next() {
		*val = String(p.q, key, dft)
	}
	return p
}

func (p *Parser) Float32(val *float32, key string) *Parser {
	if p.next() {
		v, err := RequiredFloat32(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Float32Or(val *float32, key string, dft float32) *Parser {
	if p.next() {
		v, err := Float32(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Float64(val *float64, key string) *Parser {
	if p.next() {
		v, err := RequiredFloat64(p.q, key)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}

func (p *Parser) Float64Or(val *float64, key string, dft float64) *Parser {
	if p.next() {
		v, err := Float64(p.q, key, dft)
		if err != nil {
			p.errors.Append(err)
		} else {
			*val = v
		}
	}
	return p
}
